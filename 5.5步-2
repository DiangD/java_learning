5.5-2 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》。
垃圾回收的内容过多，在5.5步中仅写入关于虚拟机内存的内容，在5.5-2中写入垃圾回收的内容。
一、概述
  首先程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭(敲黑板、划重点啦)
  一般而言栈针随着方法的进入和退出而进行着进栈、出栈动作，每个栈针分配多少内存在类结构确定以后就已知的了，所以程序计数器、虚拟机栈、本地方法栈
  的内存分配和回收都具有确定性，因此方法结束(嗯，方法)或者线程结束时内存也就跟着回收了。
  但是java堆和方法区则不然
  一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道创建了多少对象，
  这部分内存的分配和回收是动态的，垃圾收集器所处理回收的也是对象所占的内存。
二、如何确定对象已经死了
  (1)引用计数法
    嗯，简单理想的方法，但是几乎没有虚拟机会用这种方法判断对象是否已死。
    给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，引用失效时计数器减1，当计数器值为0时此对象不再使用，实现很简单，效率很高。
    但是有一个致命缺点，它很难解决对象之间相互循环引用的问题。
    public Object instance=null；
    private static final int_1MB=1024*1024；
/**
*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
*/
    private byte[]bigSize=new byte[2*_1MB]；
    public static void testGC（）{
      ReferenceCountingGC objA=new ReferenceCountingGC（）；
      ReferenceCountingGC objB=new ReferenceCountingGC（）；
      objA.instance=objB；
      objB.instance=objA；
      objA=null；
      objB=null；
//假设在这行发生GC,objA和objB是否能被回收？
      System.gc（）；
    }}
    对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经
    不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
  (2)可达性分析算法
    主流的判断对象是否死亡的方法。
    基本思想为通过一系列称为“GC Roots”的对象(敲黑板，5.5中提到过:垃圾回收器对象)作为起始点，从这些节点向下探索，搜索走过的路径被称为引用链
    (Reference Chain)(敲黑板，5.5中也提到过)，当一个对象到GC Roots没有任何引用链相连，即对于该对象，GC Roots是不可达的，那么这个对象就是
    不可用的，需要回收的。
    在java中可作为GC Roots的有:
      (a)虚拟机栈(栈针中的本地变量表)中引用的对象
      (b)方法区中类静态属性引用的对象
      (c)方法区中的常量引用的对象
      (d)本地方法栈中native方法引用的对象
三、再谈谈引用
    “引用”这块这个地址写的内容挺好的:http://www.cnblogs.com/yw-ah/p/5830458.html
    上面一直说的例如“常量引用的对象”到底是什么意思，每个名词都明白但连起来就不明白，归根到底动词“引用”没有深入的了解
    引用分为四种:强引用、软引用、弱引用、虚引用4种，引用强度降序排列。
    (a)强引用在程序代码中经常使用，object obj = new object();
    而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
    当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
    如果不使用时，要通过如下方式来弱化引用，如下：obj = null;显式地设置obj为null，或超出对象的生命周期范围，则gc认为该对象不
    存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
    (b)软引用
    用来描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前(敲黑板，此时内存已经不够了，
    要抛出内存溢出异常啦，回收这部分内存)，此时将对象列入回收范围中进行第二次回收。
    如果回收之后内存还不够，就会抛出内存溢出异常。采用SoftReference类来实现软引用。
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;
    sf.get();//有时候会返回null
    这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
    当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
    (c)弱引用
    用来描述非必须对象，它强度比软引用要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时无论当前内存是否够用
    被弱引用关联的对象都要被回收。使用WeakReference类来实现弱引用。
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null;
    wf.get();//有时候会返回null
    wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
    弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
    弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
    (d)虚引用
    最弱的一种引用关系，一个对象是否有虚引用对其一点影响都没有，不会对其生存空间产生影响，也无法通过虚引用得到对象实例，为一个对象
    设置虚引用的目的是能在这个对象被回收时收到系统通知。
    提供了PhantomReference类来实现虚引用
    ReferenceQueue queue = new ReferenceQueue ();
    PhantomReference pr = new PhantomReference (object, queue); 
四、回收方法区
  其实很多人认为方法区是没有垃圾回收的，因为方法区是所有线程共享的区域，存储着类信息，常量，静态变量等等，即编译后的代码、数据等。
  也因此方法区的回收效率很低，回收了也回收不了太大的空间。
  一般来说方法区回收的主要包括两部分内容:废弃的常量和无用的类。回收废弃的常量与回收堆中的对象差不多，比如说如果当前系统中没有
  一个String对象叫做“abc”的，即没有一个String对象引用常量池中的“abc”常量，其他地方也没有引用到这个常量，垃圾回收时如果有必要，这个“abc”常量
  会被清除出常量池。
  但是需要注意的是判断一个常量为废弃常量很简单，没有对象引用它即可，但是判断类是否是无用的类则十分地苛刻。需要同时满足下面3个条件才行。
  (a)该类的所有实例都被回收，即java堆中不存在该类的实例(对象)。
  (b)加载该类的ClassLoader已经被回收
  (c)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  所以说回收类的条件十分地苛刻。
五、垃圾回收算法
  (1)标记-清除算法
    算法分为两个阶段:“标记”和“清除”。首先标记处所有需要被回收的对象，标记完成后统一回收所有被标记的对象。标记过程就是之前的可达性分析算法中
    判定与GC roots之间没有引用链连接的对象。
    这个方法是最基本的算法，后面的算法都基于它，但是这个算法有两个明显地不足:(a)第一个是效率问题，标记过程和清除过程效率都不高(b)另一个是空间
    问题，标记清除后悔产生大量不连续的内存碎片，空间碎片过多会导致后续为某一对象分配较大内存的时候没有足够大的连续的(嗯，重点，连续的)内存空间
    从而触发另一次垃圾回收。
  (2)复制算法
    它将可用内存按容量划分为大小相等的两块，每次只使用一块，当这一块内存使用完了，就将还活着的对象复制到另一块上，然后把已用的那一块内存空间
    清除掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，
    运行高效。
    但是这种方法代价巨大：本质可用的内存为总内存的一半，嗯，代价不小。
    现在的商业虚拟机都采用这种收集算法来回收新生代(嗯，新生代和老年代，需要注意一下)，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，
    所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。
    当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟
    机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
  (3)标记-整理算法
    复制收集算法在对象存活率较高的情况下效率并不高，因为其需要较多的复制操作，更关键的
    是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中
    所有对象都100%存活的极端情况，所以在老年代中一般不能直接使用复制算法
    根据老年代的特点，有人提出了标记-整理算法，标记过程与“标记-清除”中的标记过程一致，标记完后不是直接对可回收对象进行清理，而是让所有存活的
    对象都向一端移动，然后清理掉端边界以外的内存
  (4)分代-收集算法
    没什么新意，将java堆分块，一般分为新生代和老年代，因为新生代每次垃圾回收时都会有大批对象死去，对于这部分采用复制算法，对于老年代，因为对象
    生存率高，没有额外空间担保，所以采用“标记-整理”或者“标记-清除”算法。
  (5)新生代和老年代
    在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个
    区域：Eden、From Survivor、To Survivor。
    ---------------------          ----------
    | eden  | from | to  |         |        |
    |       |      |     |         |        |
    | 8/10  |1/10  | 1/10|         |        |
    新生代: 堆的1/3                   老年代:堆的2/3
    
    新生代:新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中
    的大部分对象通常不需长久存活，具有朝生夕灭的性质。
    
