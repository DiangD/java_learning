5.5-2 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》。
垃圾回收的内容过多，在5.5步中仅写入关于虚拟机内存的内容，在5.5-2中写入垃圾回收的内容。
一、概述
  首先程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭(敲黑板、划重点啦)
  一般而言栈针随着方法的进入和退出而进行着进栈、出栈动作，每个栈针分配多少内存在类结构确定以后就已知的了，所以程序计数器、虚拟机栈、本地方法栈
  的内存分配和回收都具有确定性，因此方法结束(嗯，方法)或者线程结束时内存也就跟着回收了。
  但是java堆和方法区则不然
  一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道创建了多少对象，
  这部分内存的分配和回收是动态的，垃圾收集器所处理回收的也是对象所占的内存。
二、如何确定对象已经死了
  (1)引用计数法
    嗯，简单理想的方法，但是几乎没有虚拟机会用这种方法判断对象是否已死。
    给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，引用失效时计数器减1，当计数器值为0时此对象不再使用，实现很简单，效率很高。
    但是有一个致命缺点，它很难解决对象之间相互循环引用的问题。
    public Object instance=null；
    private static final int_1MB=1024*1024；
/**
*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
*/
    private byte[]bigSize=new byte[2*_1MB]；
    public static void testGC（）{
      ReferenceCountingGC objA=new ReferenceCountingGC（）；
      ReferenceCountingGC objB=new ReferenceCountingGC（）；
      objA.instance=objB；
      objB.instance=objA；
      objA=null；
      objB=null；
//假设在这行发生GC,objA和objB是否能被回收？
      System.gc（）；
    }}
    对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经
    不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
  (2)可达性分析算法
    主流的判断对象是否死亡的方法。
    基本思想为通过一系列称为“GC Roots”的对象(敲黑板，5.5中提到过:垃圾回收器对象)作为起始点，从这些节点向下探索，搜索走过的路径被称为引用链
    (Reference Chain)(敲黑板，5.5中也提到过)，当一个对象到GC Roots没有任何引用链相连，即对于该对象，GC Roots是不可达的，那么这个对象就是
    不可用的，需要回收的。
    在java中可作为GC Roots的有:
      (a)虚拟机栈(栈针中的本地变量表)中引用的对象
      (b)方法区中类静态属性引用的对象
      (c)方法区中的常量引用的对象
      (d)本地方法栈中native方法引用的对象
三、再谈谈引用
    上面一直说的例如“常量引用的对象”到底是什么意思，每个名词都明白但连起来就不明白，归根到底动词“引用”没有深入的了解
    引用分为四种:强引用、软引用、弱引用、虚引用4种，引用强度降序排列。
    (a)强引用在程序代码中经常使用，object obj = new object();
    而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。
    当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
    如果不使用时，要通过如下方式来弱化引用，如下：obj = null;显式地设置obj为null，或超出对象的生命周期范围，则gc认为该对象不
    存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
    (b)软引用
    用来描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前(敲黑板，此时内存已经不够了，
    要抛出内存溢出异常啦，回收这部分内存)，此时将对象列入回收范围中进行第二次回收。
    如果回收之后内存还不够，就会抛出内存溢出异常。采用SoftReference类来实现软引用。
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;
    sf.get();//有时候会返回null
    这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
    当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
    (c)弱引用
    用来描述非必须对象，它强度比软引用要弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时无论当前内存是否够用
    被弱引用关联的对象都要被回收。使用WeakReference类来实现弱引用。
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null;
    wf.get();//有时候会返回null
    wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
    弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
    弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
    
    
    
