5.5 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》
首先是内存管理：主要包括java内存区域的介绍和内存溢出异常
开始----------------------------------------------------|
|                   此为运行数据区                       |
|    方法区           虚拟机栈         本地方法栈         |
|                                                       |
|                                                       |
|    堆                      程序计数器                  |
|                                                       |
|-------------------------------------------------------|
       ^  |                         ^  |
       |  v                         |  v
    执行引擎        ->              本地库接口      ->          本地方法库
    
    所有线程共享的数据区: 方法区、堆、执行引擎、本地库接口
    线程隔离的数据区（各线程私有的）：虚拟机栈、本地方法栈、程序计数器。
    
    上述为java虚拟机运行时的数据区
    
    下面我来一个个介绍：
    (1)程序计数器:各线程私有的，书上的说法：它可以看作是当前线
                 程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器
                 工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这
                 个计数器来完成。
                 我来解释一下，我们都知道多线程并发是指线程轮流切换，轮流使用控制器，通过分配控制器的时间来实现的，比如说1秒内，多少毫秒给这个线程
                 多少毫秒给那个线程，如此实现多线程。在某一时刻内，控制器只能处理一个线程。
                 当线程切换，最后又回来时，控制器怎么知道这个线程进行到哪一步了，即上次执行到第几行指令，这次从哪开始，这时程序计数器发挥作用，其能
                 使得回到正确的执行位置。
                 也因此程序计数器是各线程所私有的。
    (2)java虚拟机栈:java虚拟机栈也为线程所私有，虚拟机栈描述的是java方法(敲黑板，注意是方法)执行的内存模型：每个方法在执行的同时
                   都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，
                   就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
                 
