5.5 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》
首先是内存管理：主要包括java内存区域的介绍和内存溢出异常
开始----------------------------------------------------|
|                   此为运行数据区                       |
|    方法区           虚拟机栈         本地方法栈         |
|                                                       |
|                                                       |
|    堆                      程序计数器                  |
|                                                       |
|-------------------------------------------------------|
       ^  |                         ^  |
       |  v                         |  v
    执行引擎        ->              本地库接口      ->          本地方法库
    
    所有线程共享的数据区: 方法区、堆、执行引擎、本地库接口
    线程隔离的数据区（各线程私有的）：虚拟机栈、本地方法栈、程序计数器。
    
    上述为java虚拟机运行时的数据区
    
    下面我来一个个介绍：
    (1)程序计数器:各线程私有的，书上的说法：它可以看作是当前线
                 程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器
                 工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这
                 个计数器来完成。
                 我来解释一下，我们都知道多线程并发是指线程轮流切换，轮流使用控制器，通过分配控制器的时间来实现的，比如说1秒内，多少毫秒给这个线程
                 多少毫秒给那个线程，如此实现多线程。在某一时刻内，控制器只能处理一个线程。
                 当线程切换，最后又回来时，控制器怎么知道这个线程进行到哪一步了，即上次执行到第几行指令，这次从哪开始，这时程序计数器发挥作用，其能
                 使得回到正确的执行位置。
                 也因此程序计数器是各线程所私有的。
    (2)java虚拟机栈:java虚拟机栈也为线程所私有，虚拟机栈描述的是java方法(敲黑板，注意是方法)执行的内存模型：每个方法在执行的同时
                   都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表(重点)、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，
                   就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧是方法运行时的基础数据结构
                   通常人们所讨论的把虚拟机内存区分成堆和栈两个部分，栈就是虚拟机栈，或者说虚拟机栈中的局部变量表。
                   局部变量表存储的内容:编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，
                                      它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
                                      returnAddress类型（指向了一条字节码指令的地址）。
                   局部变量表，其所需的内存在编译期间已经确定，进入一个方法时，这个方法在帧中分配多大的局部变量空间已经确定，方法在运行期间不会改变局部变量表
                   的大小。
                   
                   虚拟机栈这个部分可能会出现两个异常：(1)当线程申请的栈深度大于虚拟机所允许的深度，则会跑出stackoverflowerror异常(2)对于大部分可动态扩展
                   的虚拟机栈，如果扩展时无法申请到足够的内存，则会抛出outofmemoryerror异常。
    (3)本地方法栈：其重用与虚拟机栈相似，二者区别是虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行native方法服务
                  native方法:简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java
                  语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的
                  函数。对于native方法而言，Java程序不会为该方法提供实现体。
                  例子：
                  public class NativeTest{  
                     public native void info();  
                  } 
    (4)java堆:注意堆与栈的区别。
              java堆是虚拟机栈中所占内存最大的一块，它是所有线程共享的一块内存区域，虚拟机启动时创建，其唯一(敲黑板，注意啦)目的是存放对象实例，
              几乎所有的对象实例都在这里分配内存。
              规范上说；所有的对象实例和数组都在堆上分配内存。
              垃圾回收主要是回收对象实例所占的内存，用暖神的说法：注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。
              比如，文件、管道、Socket、数据库连接等，垃圾回收是不会帮你关闭的。所以java堆是垃圾收集器管理的主要区域。
              java堆的一般特性:Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固
                              定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存
                              完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
    (5)方法区:各个线程所共享的区域。其用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
              Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。
              相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要
              是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域
              的回收确实是必要的。
    (6)运行时常量池:注意，运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常
                   量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池
                   中存放。
                   首先我们先来看看常量池的信息：Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。
                   所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，
                   占用class文件绝大部分空间。
                   而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，
                   就是指方法区中的运行时常量池。
                   常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）
                   和对象型（如String及数组）的常量值(final)(敲黑板，常量值才是重点，各种基本类型和对象型的常量值，不是基本类型和对象型，
                   此二者存在虚拟机栈中的局部变量表中)还包含一些以文本形式出现的符号引用，比如：类和接口的全限定名； 字段的名称和描述符； 
                   方法和名称和描述符。虚拟机必须为每个被装载的类型维护一个常量池。
                   可能会和虚拟机栈有些冲突误会：虚拟机栈保存的主要是局部变量表，用于描述方法执行的内存模型，而运行常量池保存的是被保存在
                   已编译的.class文件中的一些数据。
    (7)直接内存
              直接内存并不是java虚拟机运行数据区的一部分，但是这部分内存也被频繁地使用，
              在JDK1.4以后加入了NIO(new input/output)类，引入了基础通道（Channel）与缓冲区（Buffer）的I/O方式，这种方法使得native函数库
              直接分配堆外内存(直接内存)，然后通过java堆中的一个DirectByteBuffer对象作为这块内存的引用进行操作，从而避免了java堆和native堆
              中来回复制数据
              直接内存的分配不受java堆大小的限制，但由于是内存，所以肯定受到总内存大小的限制，所以动态扩展时若忽略了直接内存则有可能导致
              OutOfMemoryError异常
              
              
                  
                  
                   
                 
