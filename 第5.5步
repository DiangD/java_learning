5.5 这时候应该已经涉及了Java的垃圾回收。要留意即使有垃圾回收的情况下也会发生的内存泄露（如自己设计数组容器，元素是引用，逻辑上删除了元素，
但并没有清成null）。注意垃圾回收只能回收内存中的对象，除了内存以外，其它资源不能依靠垃圾回收来关闭。比如，文件、管道、Socket、数据库连接等，
垃圾回收是不会帮你关闭的。
本章内容主要是内存管理和垃圾回收机制参考，参考资料主要为《深入理解java虚拟机》的前三章和部分《java高手真经》
首先是内存管理：主要包括java内存区域的介绍和内存溢出异常
开始----------------------------------------------------|
|                   此为运行数据区                       |
|    方法区           虚拟机栈         本地方法栈         |
|                                                       |
|                                                       |
|    堆                      程序计数器                  |
|                                                       |
|-------------------------------------------------------|
       ^  |                         ^  |
       |  v                         |  v
    执行引擎        ->              本地库接口      ->          本地方法库
    
    所有线程共享的数据区: 方法区、堆、执行引擎、本地库接口
    线程隔离的数据区（各线程私有的）：虚拟机栈、本地方法栈、程序计数器。
    
    上述为java虚拟机运行时的数据区
    
    下面我来一个个介绍：
    (1)程序计数器:各线程私有的，书上的说法：它可以看作是当前线
                 程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器
                 工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这
                 个计数器来完成。
                 我来解释一下，我们都知道多线程并发是指线程轮流切换，轮流使用控制器，通过分配控制器的时间来实现的，比如说1秒内，多少毫秒给这个线程
                 多少毫秒给那个线程，如此实现多线程。在某一时刻内，控制器只能处理一个线程。
                 当线程切换，最后又回来时，控制器怎么知道这个线程进行到哪一步了，即上次执行到第几行指令，这次从哪开始，这时程序计数器发挥作用，其能
                 使得回到正确的执行位置。
                 也因此程序计数器是各线程所私有的。
    (2)java虚拟机栈:java虚拟机栈也为线程所私有，虚拟机栈描述的是java方法(敲黑板，注意是方法)执行的内存模型：每个方法在执行的同时
                   都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表(重点)、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，
                   就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧是方法运行时的基础数据结构
                   通常人们所讨论的把虚拟机内存区分成堆和栈两个部分，栈就是虚拟机栈，或者说虚拟机栈中的局部变量表。
                   局部变量表存储的内容:编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，
                                      它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
                                      returnAddress类型（指向了一条字节码指令的地址）。
                   局部变量表，其所需的内存在编译期间已经确定，进入一个方法时，这个方法在帧中分配多大的局部变量空间已经确定，方法在运行期间不会改变局部变量表
                   的大小。
                   
                   虚拟机栈这个部分可能会出现两个异常：(1)当线程申请的栈深度大于虚拟机所允许的深度，则会跑出stackoverflowerror异常(2)对于大部分可动态扩展
                   的虚拟机栈，如果扩展时无法申请到足够的内存，则会抛出outofmemoryerror异常。
    (3)本地方法栈：其重用与虚拟机栈相似，二者区别是虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行native方法服务
                  native方法:简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java
                  语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的
                  函数。对于native方法而言，Java程序不会为该方法提供实现体。
                  例子：
                  public class NativeTest{  
                     public native void info();  
                  } 
    (4)java堆:注意堆与栈的区别。
              java堆是虚拟机栈中所占内存最大的一块，它是所有线程共享的一块内存区域，虚拟机启动时创建，其唯一(敲黑板，注意啦)目的是存放对象实例，
              几乎所有的对象实例都在这里分配内存。
              规范上说；所有的对象实例和数组都在堆上分配内存。
              垃圾回收主要是回收对象实例所占的内存，所以java堆是垃圾收集器管理的主要区域。
              java堆的一般特性:Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固
                              定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存
                              完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
    (5)方法区:各个线程所共享的区域。
              
                  
                  
                   
                 
